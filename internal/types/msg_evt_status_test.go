package types

import (
	"encoding/binary"
	"errors"
	"math"
	"testing"
)

func TestInverterStatusUnmarshalBinary(t *testing.T) {
	t.Run("raw struct should have binary size of 86", func(t *testing.T) {
		var payload rawInverterStatus

		if binary.Size(payload) != 86 {
			t.Fatalf("unexpected struct binary size: %d", binary.Size(payload))
		}
	})

	t.Run("should successfully decode raw messages", func(t *testing.T) {
		messages := [][]byte{
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x45, 0x06, 0x0a, 0x4c, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x00, 0x3a, 0x96, 0x32, 0x05,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0x94, 0x08, 0x4a, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x1f, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x44, 0xd2, 0x0a, 0x64, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x00, 0x3a, 0x9a, 0x32, 0x08,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0x96, 0x08, 0x5e, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x9a, 0x32, 0x08,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x26, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x04, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x44, 0xf6, 0x0a, 0x84, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x0c, 0x3a, 0xa2, 0x32, 0x01,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0xa2, 0x08, 0x76, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x40, 0x3a, 0xa2, 0x32, 0x01,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x5c, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x45, 0x04, 0x0a, 0xaa, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x19, 0x3a, 0xec, 0x32, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0xba, 0x08, 0x92, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x40, 0x3a, 0xec, 0x32, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0xb1, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x04, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x45, 0x30, 0x0a, 0xdb, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x26, 0x3b, 0x1d, 0x32, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0x90, 0x08, 0xbd, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x4c, 0x3b, 0x1d, 0x32, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x3f, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x45, 0x38, 0x0a, 0xe2, 0x00, 0x03,
				0xcf, 0xf6, 0x21, 0x26, 0x3b, 0x0f, 0x31, 0xf9,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0xa4, 0x08, 0xd1, 0x00, 0x03,
				0x2d, 0xc7, 0x21, 0x59, 0x3b, 0x0f, 0x31, 0xf9,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0xd7, 0x16,
			},
			{
				0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
				0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
				0x70, 0x79, 0x45, 0x38, 0x0a, 0x4c, 0x00, 0x03,
				0xcf, 0xda, 0x21, 0x00, 0x3a, 0xc3, 0x32, 0x07,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
				0x70, 0x79, 0x47, 0x92, 0x08, 0x4a, 0x00, 0x03,
				0x2d, 0xb0, 0x21, 0x33, 0x3a, 0xc3, 0x32, 0x07,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0xad, 0x16,
			},
		}

		for _, msg := range messages {
			s := &InverterStatus{}
			err := s.UnmarshalBinary(msg)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			switch {
			case s.InverterId != "30587612":
				t.Fatalf("unexpected inverter serial: %s", s.InverterId)
			case s.Module1.ModuleId != "30587612":
				t.Fatalf("unexpected module 1 id: %s", s.Module1.ModuleId)
			case s.Module2.ModuleId != "30587613":
				t.Fatalf("unexpected module 2 id: %s", s.Module2.ModuleId)
			}
		}
	})

	t.Run("should decode inverter state correctly", func(t *testing.T) {
		msg := []byte{
			0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
			0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
			0x70, 0x79, 0x45, 0x06, 0x0a, 0x4c, 0x00, 0x03,
			0xcf, 0xda, 0x21, 0x00, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
			0x70, 0x79, 0x47, 0x94, 0x08, 0x4a, 0x00, 0x03,
			0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x1f, 0x16,
		}

		s := &InverterStatus{}
		err := s.UnmarshalBinary(msg)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		epsilon := 0.001

		switch {
		case s.InverterId != "30587612":
			t.Fatalf("unexpected inverter serial: %s", s.InverterId)
		case s.Module1.ModuleId != "30587612":
			t.Fatalf("unexpected module1 id: %s", s.Module1.ModuleId)
		case s.Module1.FirmwareVersion != "112/121":
			t.Fatalf("unexpected module1 firmware: %s", s.Module1.FirmwareVersion)
		case math.Abs(s.Module1.InputVoltageDC-34.511719) > epsilon:
			t.Fatalf("unexpected module1 input voltage dc: %f", s.Module1.InputVoltageDC)
		case math.Abs(s.Module1.OutputPowerAC-41.187500) > epsilon:
			t.Fatalf("unexpected module1 output power ac: %f", s.Module1.OutputPowerAC)
		case math.Abs(s.Module1.TotalEnergy-30.495361) > epsilon:
			t.Fatalf("unexpected module1 total energy: %f", s.Module1.TotalEnergy)
		case math.Abs(s.Module1.Temperature-26) > epsilon:
			t.Fatalf("unexpected module1 temp: %f", s.Module1.Temperature)
		case math.Abs(s.Module1.OutputVoltageAC-234.343750) > epsilon:
			t.Fatalf("unexpected module1 output voltage ac: %f", s.Module1.OutputVoltageAC)
		case math.Abs(s.Module1.OutputFrequencyAC-50.019531) > epsilon:
			t.Fatalf("unexpected module1 frequency ac: %f", s.Module1.OutputFrequencyAC)
		case s.Module2.ModuleId != "30587613":
			t.Fatalf("unexpected module2 id: %s", s.Module2.ModuleId)
		case s.Module2.FirmwareVersion != "112/121":
			t.Fatalf("unexpected module2 firmware: %s", s.Module2.FirmwareVersion)
		case math.Abs(s.Module2.InputVoltageDC-35.789062) > epsilon:
			t.Fatalf("unexpected module2 input voltage dc: %f", s.Module2.InputVoltageDC)
		case math.Abs(s.Module2.OutputPowerAC-33.156250) > epsilon:
			t.Fatalf("unexpected module2 output power ac: %f", s.Module2.OutputPowerAC)
		case math.Abs(s.Module2.TotalEnergy-25.427734) > epsilon:
			t.Fatalf("unexpected module2 total energy: %f", s.Module2.TotalEnergy)
		case math.Abs(s.Module2.Temperature-26.398438) > epsilon:
			t.Fatalf("unexpected module2 temp: %f", s.Module2.Temperature)
		case math.Abs(s.Module2.OutputVoltageAC-234.343750) > epsilon:
			t.Fatalf("unexpected module2 output voltage ac: %f", s.Module2.OutputVoltageAC)
		case math.Abs(s.Module2.OutputFrequencyAC-50.019531) > epsilon:
			t.Fatalf("unexpected module2 frequency ac: %f", s.Module2.OutputFrequencyAC)
		}
	})

	t.Run("should ignore extraneous bytes", func(t *testing.T) {
		msg := []byte{
			0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
			0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
			0x70, 0x79, 0x45, 0x06, 0x0a, 0x4c, 0x00, 0x03,
			0xcf, 0xda, 0x21, 0x00, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
			0x70, 0x79, 0x47, 0x94, 0x08, 0x4a, 0x00, 0x03,
			0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x1f, 0x16, 0x32, 0x05,
			0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
		}

		s := &InverterStatus{}
		err := s.UnmarshalBinary(msg)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
	})

	t.Run("should return error if frame end byte invalid", func(t *testing.T) {
		msg := []byte{
			0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
			0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
			0x70, 0x79, 0x45, 0x06, 0x0a, 0x4c, 0x00, 0x03,
			0xcf, 0xda, 0x21, 0x00, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
			0x70, 0x79, 0x47, 0x94, 0x08, 0x4a, 0x00, 0x03,
			0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x1f, 0x17,
		}

		s := &InverterStatus{}
		err := s.UnmarshalBinary(msg)
		if err == nil {
			t.Fatalf("expected error but was nil")
		}
		if !errors.Is(err, ErrStatusFrameDecodeFailure) {
			t.Fatalf("expected error: %v", err)
		}
	})

	t.Run("should return error if data length invalid", func(t *testing.T) {
		msg := []byte{
			0x68, 0x00, 0x56, 0x68, 0x10, 0x51, 0x30, 0x58,
			0x76, 0x12, 0x70, 0x01, 0x79, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x12,
			0x70, 0x79, 0x45, 0x06, 0x0a, 0x4c, 0x00, 0x03,
			0xcf, 0xda, 0x21, 0x00, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x30, 0x58, 0x76, 0x13,
			0x70, 0x79, 0x47, 0x94, 0x08, 0x4a, 0x00, 0x03,
			0x2d, 0xb0, 0x21, 0x33, 0x3a, 0x96, 0x32, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}

		s := &InverterStatus{}
		err := s.UnmarshalBinary(msg)
		if err == nil {
			t.Fatalf("expected error but was nil")
		}
		if !errors.Is(err, ErrStatusFrameDecodeFailure) {
			t.Fatalf("expected error: %v", err)
		}
	})
}
